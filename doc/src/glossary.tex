\newglossaryentry{dt}
{
	name = {DT},
	long = {Device Tree},
	first = {\glsentrylong{dt} (\glsentryname{dt})},
	description = {
		A device structure that describes the hardware.
		It is used in systems that offer no BIOS-like functionality,
		as it is the norm in the embedded world. It presents 
		at the operating system the peripherals that cannot be auto-detected.
	},
}

\newglossaryentry{devc}
{
	name = {devc},
	long = {Device Configuration controller},
	first = {\glsentrylong{devc} (\glsentryname{devc})},
	description = {
		A configuration controller for the Zynq-7000.
		It contains an \gls{axi} to \gls{pcap} bridge
		and therefore is the intermediary
		for programming the FPGA during partial reconfiguration.
	},
}

\newglossaryentry{pcap}
{
	name = {PCAP},
	long = {Processor Configuration Access Port},
	first = {\glsentrylong{pcap} (\glsentryname{pcap})},
	description = {\emph{\glsentrylong{pcap}}:
		The port to the FPGA configuration interface from the PS side.
		In Xilinx FPGA-SoCs it is the default port from boot-up.
		In any time, the processor may relinquish the control to \gls{icap},
		as well as reclaim it back. It is not available on the non-SoC FPGAs.
	},
	see={icap},
}


\newglossaryentry{icap}
{
	name = {ICAP},
	long = {Internal Configuration Access Port},
	first = {\glsentrylong{icap} (\glsentryname{icap})},
	description = {\emph{\glsentrylong{icap}}:
		The port to the FPGA configuration interface from the PL side.
	},
	see={pcap},
}


\newglossaryentry{rm}
{
	name = {reconfigurable module},
	description = {
		An hierarchical design module that is defined as partially reconfigurable.
	},
}


\newglossaryentry{rl}
{
	name = {reconfigurable logic},
	description = {
		Logic that is part of a \gls{rm}.
	},
	see = {rm},
}


\newglossaryentry{rp}
{
	name = {reconfigurable partition},
	description = {
		A physical region of the FPGA, defined by \glspl{pblock},
		that instantiates a single \gls{rm}.
	},
	see = {pblock,rm},
}

\newglossaryentry{rf}
{
	name = {reconfigurable frame},
	description = {
		The smallest reconfigurable physical region of the FPGA. 
		In 7-series it is one element (\gls{clb}, \gls{bram} or \gls{dsp}) wide by one clock region high.
		In UltraScale+ it is a pair of \glspl{dsp} or a single \gls{bram}/\gls{dsp} 
		tile and their neighboring \glspl{clb}.
	},
}


\newglossaryentry{ooc}
{
	name = {OOC synthesis},
	long = {out-of-context synthesis},
	first = {\glsentrylong{ooc} (\glsentryname{ooc})},
	description = {\emph{\glsentrylong{ooc}}:
		A bottom-up hierarchical approach in design synthesis. 
		Each design module is synthesized independently of the final design.
		This approach disables optimizations accross the boundaries of the
		synthesized module as it has no knowledge of the final design.
		This characteristic is essential to a P.R. design, however it is also
		used in normal workflow as it greatly reduces total synthesis time by
		re-synthesizing only the affected logic.
	},
}

\newglossaryentry{dcp}
{
	name = {DCP},
	long = {Device Check-Point},
	first = {\glsentrylong{dcp} (\glsentryname{dcp})},
	description = {\emph{\glsentrylong{dcp}}:
		The saved state of a design. It may be at post-synthesis, post-placement or post-routing.
	},
}

\newglossaryentry{staticdesign}
{
	name = {static design},
	description = {
		The part of the design that is not dynamically reconfigurable.
	},
}

\newglossaryentry{pp}
{
	name = {partition pin},
	description = {
		A logical pin and physical site of a P.R. design that 
		serves as a connection point between the static and the reconfigurable logic.
	},
}

\newglossaryentry{mgt}
{
	name = {MGT},
	long = {Multi Gigabit Transceiver},
	first = {\glsentrylong{mgt} (\glsentryname{mgt})},
	firstplural = {\glsentrylong{mgt}s (\glsentryname{mgt}s)},
	description = {\emph{\glsentrylong{mgt}}:
		A programmable high-speed serial interface.
	}
}

\newglossaryentry{gsr}
{
	name = {GSR},
	long = {Global Set/Reset},
	first = {\glsentrylong{gsr} (\glsentryname{gsr})},
	description = {\emph{\glsentrylong{gsr}}:
		A globally routed signal that forces logic to 
		quiescence while the device is being programmed.
	},
}

\newglossaryentry{amba}
{
	name = {AMBA},
	long = {Advanced Microcontroller Bus Architecture},
	first = {\glsentrylong{amba} (\glsentryname{amba})},
	description = {\emph{\glsentrylong{amba}}:
		A family of interconnect protocols that originates 
		from the ARM microcontrollers but now it is used widely
		in modern ARM SoCs, including the FPGA-SoCs from Xilinx.
	},
}


\newglossaryentry{dap}
{
	name = {DAP},
	long = {Device Access Port},
	first = {\glsentrylong{dap} (\glsentryname{dap})},
	description = {\emph{\glsentrylong{dap}}:
		An external debug interface to an ARM core. It can debug a running system
		without the intervention of the CPU. It is available in Xilinx FPGA-SoCs.
	},
}

\newglossaryentry{gp}
{
	name = {GP},
	long = {General Purpose port},
	description = {\emph{\glsentrylong{gp}}:
		An AXI compatible port, found in Zynq-7000 but not in UltraScale+.
		It is present both as a slave to PS and as a master. 
		It is 32 bit wide and runs at up to 150MHz.
	},
	see={mgp,sgp},
}

\newglossaryentry{sgp}
{
	name = {S\_GP},
	long = {General Purpose Slave port},
	description = {\emph{\glsentrylong{sgp}}:
		A \glsentrylong{gp} that is a slave to the PS. 
		In Zynq-7000 there are available two of such ports.
	},
	see={gp},
}

\newglossaryentry{mgp}
{
	name = {M\_GP},
	long = {General Purpose Master port},
	description = {\emph{\glsentrylong{mgp}}:
		A \glsentrylong{gp} that is a master from the PS. 
		In Zynq-7000 there are available two of such ports.
	},
	see={gp},
}

\newglossaryentry{ocm}
{
	name = {OCM},
	long = {On-Chip Memory},
	first = {\glsentrylong{ocm} (\glsentryname{ocm})},
	description = {\emph{\glsentrylong{ocm}}:
		A small on-chip SRAM in the PS of both Zynq-7000 and UltraScale+.
		Its primary role is a low-latency synchonization point between the ARM cores.
	},
}

\newglossaryentry{gpio}
{
	name = {GPIO},
	description = {
		General Purpose I/O, ie unstrctured data port. 
		The handshaking, synchronization and error correction
		is left as a responsibility of the communicating endpoints.
	}
}

\newglossaryentry{fifo}
{
	name = {FIFO},
	description = {
		First-In First-Out, a method of queueing access,
		however almost universally refers to the buffering hardware
		that implements this policy.
	}
}


\newglossaryentry{chi}
{
	name = {CHI},
	long = {Coherent Hub Interface},
	first = {\glsentrylong{chi} (\glsentryname{chi})},
	description = {	\emph{\glsentrylong{chi}}:
		An evolutionary step from \gls{ace}, this protocol the newer multi-core SoCs.
		It is not present in UltraScale+.
	},
	see={ace},
}

\newglossaryentry{ace}
{
	name = {ACE},
	long = {\gls{axi} Coherency Extensions},
	first = {\glsentrylong{ace} (\glsentryname{ace})},
	description = {\emph{\glsentrylong{ace}}:
		A cache coherent port in \gls{amba} \gls{axi} version 4. It offers full (two-way)
		coherency between a processor and a peripheral with caches.
	},
	see={acelite},
}

\newglossaryentry{bram}
{
	name = {BRAM},
	first = {\glsentrylong{bram} (\glsentryname{bram})},
	description = {\emph{\glsentrylong{bram}}:
		A specialized type of on-chip FPGA memory resource with one cycle access latency.
		Each tile may be used as a single 36kibit element (BRAM36) or as two 18kibit (BRAM18).
		Optionally, BRAM may be configured as a FIFO and is capable of ECC.
	}
	see = {lutram},
}

\newglossaryentry{lutram}
{
	name = {distributed RAM},
	description = {\emph{\Gls{lutram} or LUT RAM}:
		Memory implemented in generic LUTs that are distributed over all the FPGA silicon area.
	},
	see = {bram,lut},
}


\newglossaryentry{clb}
{
	name = {CLB},
	description = {\emph{Configurable Logic Block}:
		The fundamental configurable block in an FPGA. It consists of a few \Glspl{slice}
		(the number depends on the architecture) and a switch matrix that provides
		access to the general routing matrix.
	},
	see = {slice},
}

\newglossaryentry{dsp}
{
	name = {DSP},
	description = {
		A specialized FPGA resource that implements an integer pre-adder,
		a multiplier and an accumulator. In 7-series a DSP48E1 is implemented,
		where the pre-adder is 25 bits wide, the multiplier is 25 by 18 bits wide,
		and the accumulator is 48 bits wide (hence the name). 
		The UltraScale/UltraScale+ feature a more advanced version, the DSP48E2,
		which features a 27 by 18 bit wide multiplier.
	}
}


\newglossaryentry{slice}
{
	name = {slice},
	description = {
		The ``Slice'' in Xilinx terminology or ``Adaptive Logic Module'' in Altera's,
		is the most basic group of configurable elements. It contains a few \glspl{lut},
		fixed logic such as multiplexers and fast carry propagation logic, as well as
		some memory elements (flip-flops). An FPGA architecture may define several slice types
		that co-exist in the same chip.
	},
	see = {lut},
}

\newglossaryentry{lut}
{
	name = {LUT},
	description = {\emph{Look-Up Table}: 
		A programmable function generator. It decides $n$ outputs according to $m$ inputs
		over constant time. 
		The number of the inputs, the outputs and the legal configurations
		are architecture dependant. 
		Essentially, it is a bit-addressable array of SRAM memory cells
		that stores the boolean function truth table.
	},
}

\newglossaryentry{pblock}
{
	name = {pblock},
	description = {\emph{Partition Block}:
		A group of physical FPGA resources. It may be dynamically reconfigurable or not.
		If it is, the architecture will impose several shape, content and placement restrictions.
		If it is not, it acts as its assigned module container but it may as well share logic
		from other modules.
	},
}

\newglossaryentry{tns}
{
	name = {TNS},
	long = {Total Negative Slack},
	first = {\glsentrylong{tns} (\glsentryname{tns})},
	description = {\emph{\glsentrylong{tns}}:
		A metric of how far the timing closure is. It represents the sum
		of negative slacks of all paths that fail timing constraints.
	}
}

\newglossaryentry{drc}
{
	name = {DRC},
	long = {Design Rule Checking},
	%first = {\glsentrylong{drc} (\glsentryname{drc})},
	description = {\emph{\glsentrylong{drc}}:
		A process of design verification in order to conform to the requirements
		of the implementing technology.
	}
}

\newglossaryentry{acelite}
{
	name = {ACE-Lite},
	long = {\glsentrylong{ace}, Light},
	description = {\emph{\glsentrylong{acelite}}:
		A lightweight version of the \gls{ace} protocol. It offers only IO (one-way) coherency
		between a processor and a peripheral without caches.
	},
	see={ace},
}


\newglossaryentry{ahb}
{
	name = {AHB},
	long = {Advanced High-performance Bus},
	first = {\glsentrylong{ahb} (\glsentryname{ahb})},
	description = {\emph{\glsentrylong{ahb}}:
		A high-performance, single-channel multiple-master shared bus, 
		introduced with \gls{amba} version 2.
	},
}


\newglossaryentry{ahblite}
{
	name = {AHB-Lite},
	long = {\glsentrylong{ahb}, Light},
	description = {\emph{\glsentrylong{ahblite}}:
		A lightweight version of \gls{ahb}, introduced with \gls{amba} version 2.
		It simplifies the protocol by allowing only one master in the bus.
	},
}


\newglossaryentry{apb}
{
	name = {APB},
	long = {Advanced Peripheral Bus},
	first = {\glsentrylong{apb} (\glsentryname{apb})},
	description = {\emph{\glsentrylong{apb}}:
		A low-complexity, low-performance shared-bus, defined in the original
		specification of \gls{amba}.
	},
}


\newglossaryentry{axi}
{
	name = {AXI},
	long = {Advanced eXtensible Interface},
	first = {\glsentrylong{axi} (\glsentryname{axi})},
	description = {\emph{\glsentrylong{axi}}:
		A high-performance \gls{burst} capable protocol introduced in \gls{amba} version 3.
		In \gls{amba} version 4 it was extended to support a \gls{burst} size of up to 256,
		up from 16 in version 3. It does not support cache coherency.
	},
	see={axilite},
}


\newglossaryentry{axilite}
{
	name = {AXI-Lite},
	long = {\glsentrylong{axi}, Light},
	description = {\emph{\glsentrylong{axilite}}:
		A lightweight version of the \gls{axi} protocol. 
		It does not support \gls{burst} transactions.
	},
	see={axi},
}

\newglossaryentry{axistream}
{
	name = {AXI-Stream},
	description = {
		A streaming version of \gls{axi}. It has no notion of address spaces
		and therefore it exchanges no addressing information. 
		This results in both higher performance and (much) lower complexity.
	},
	see={axi},
}



\newglossaryentry{cci}
{
	name = {CCI},
	long = {Cache Coherent Interconnect},
	description = {\emph{\glsentrylong{cci}}:
		A cache-coherent interconnect by ARM. 
		It can provide both full (two-way) cache coherency between the processor and
		a peripheral with caches or IO (one-way) coherency to cache-less
		peripherals. Used in UltraScale+ devices.
	},
	see = {IO Coherency},
}


\newglossaryentry{scu}
{
	name = {SCU},
	long = {Snoop Control Unit},
	first = {\glsentrylong{scu} (\glsentryname{scu})},
	description = {\emph{\glsentrylong{scu}}:
		The logic that implements cache coherency at the processor side.
	}
}

\newglossaryentry{acp}
{
	name = {ACP},
	long = {Accelerator Coherency Port},
	first = {\glsentrylong{acp} (\glsentryname{acp})},
	description = {\emph{\glsentrylong{acp}}:
		An \gls{axi} port that offers IO-Coherency to a non cache-aware AXI Master.
	},
}


\newglossaryentry{hp}
{
	name = {HP},
	long = {High Performance port},
	first = {\glsentrylong{hp} (\glsentryname{hp})},
%	firstplural={\glsentrylong{hp}\glspluralsuffix\ (\glsentryname{hp}\glspluralsuffix)},
	description = {\emph{\glsentrylong{hp}}:
		A high-performance non-coherent port that interfaces 
		the PS with the PL in Xilinx Zynq FPGA-SoCs.
		In Zynq-7000 it can be configured as a 32 or 64 bit port, running at up to 150MHz.
		In Zynq UltraScale+ it can also be configured as a 128 bit port and the maximum
		frequency is raised to 333MHz.
	},
}

\newglossaryentry{afi}
{
	name = {AFI},
	long = {\gls{axi} FIFO Interface},
	first = {\glsentrylong{afi} (\glsentryname{afi})},
	description = {\emph{\glsentrylong{afi}}:
		FIFO buffers placed in silicon just after the \gls{hp} ports. 
		Their purpose is to smooth out traffic in order to make DDR access more efficient.
	},
}

\newglossaryentry{hpm}
{
	name = {HPM},
	long = {High Performance Master port},
	longplural = {skata},
	description = {\emph{\glsentrylong{hpm}}:
		A high-performance non-coherent port of UltraScale+. 
		It offers equivalent performance to \gls{hp} ports but it a master port to the PL.
		In Zynq-7000 this funcionality was offered by the \gls{mgp} ports.
	},
	see = {mgp},
}

\newglossaryentry{hpc}
{
	name = {HPC},
	long = {High Performance Coherent port},
	description = {
		A coherent version of \gls{hp}, present in UltraScale+.
		The coherency is provided by the \gls{cci}.
		It is destined to replace the \gls{acp} in many usage scenarios.
	},
	see = {hp,acp},
}


\newglossaryentry{fpd}
{
	name = {FPD},
	long = {Full Power Domain},
	description = {\emph{\glsentrylong{fpd}}:
		The UltraScale+'s \gls{pd} where the A53 cores reside,
		along with the high-speed peripherals (PCIe, SATA, GPU, etc).
	},
	see = {pd},
}

\newglossaryentry{lpd}
{
	name = {LPD},
	long = {Low Power Domain},
	description = {\emph{\glsentrylong{fpd}}:
		The UltraScale+'s \gls{pd} where the R5 cores reside,
		along with the I/O peripherals and the \gls{ocm} memory.
	},
	see = {pd},
}

\newglossaryentry{bpd}
{
	name = {BPD},
	long = {Battery Power Domain},
	description = {\emph{\glsentrylong{fpd}}:
		A small \gls{pd} in UltraScale+ 
		that contains the most basic components,
		like the oscillator, the RTC, etc.
	},
	see = {pd},
}

\newglossaryentry{plpd}
{
	name = {PLPD},
	long = {Programmable Logic Power Domain},
	description = {\emph{\glsentrylong{fpd}}:
		The UltraScale+'s \gls{pd} that contains the
		programmable logic, including
		the high-speed tranceivers.
	},
	see = {pd},
}


\newglossaryentry{pd}
{
	name = {power domain},
	description = {
		A logical partition of the UltraScale+ system that 
		can be individually isolated and powered.
		A power cut-off in one power domain, even accidental,
		can be configured to not affect the correct functional behavior
		of the others.
		There are four power domains in total.
	},
	see = {plpd,fpd,lpd,bpd},
}

\newglossaryentry{beat}
{
	name = {beat},
	description = {A transfer of an elementary datum through the Full AXI or AXI-Lite channel.}
}

\newglossaryentry{burst}
{
	name = {burst},
	description = {A sequence of AXI \Glspl{beat} that transmits the \gls{transaction} payload.
	Does not include handshaking and address information.}.
}

\newglossaryentry{transaction}
{
	name = {transaction},
	description = {A complete set of handshaking, addressing, data transfer and acknowledge on
	an AXI channel.},
}


\newglossaryentry{hardip}
{
	name = {hard-IP},
	description = {
		A non-programmable hardware component implemented in silicon.
	},
	see={soft-ip},
}

\newglossaryentry{softip}
{
	name = {soft-IP},
	description = {
		A programmable hardware component implemented in the FPGA \gls{fabric}.
	},
	see={hard-ip},
}

\newglossaryentry{fabric}
{
	name = {fabric},
	description = {The programmable structural units of an FPGA.},
}

\newglossaryentry{apu}
{
	name = {APU},
	long = {Application Processing Unit},
	description = {\emph{\glsentrylong{apu}}:
		The hardware unit that encompasses the application processors (ie the Cortex-A cores),
		the \gls{scu} and the cache.
	},
}

\newglossaryentry{rpu}
{
	name = {RPU},
	long = {Real-time Processing Unit},
	description = {\emph{\glsentrylong{rpu}}:
		The hardware unit that encompasses the real-time processors (ie the Cortex-R cores).
	},
}


\newglossaryentry{IO Coherency}
{
	name = {IO Coherency},
	description = {
		IO Coherency, or one-way coherency, is weaker form of coherency where
		the peripheral can snoop the processor but the processor cannot snoop the peripheral.
		That is, the peripheral can read directly from the processor caches while
		writing to memory will automatically invalidate them. The processor cannot,
		therefore the peripheral may either do not posess any caches at all, or they
		are non-coherent and manually managed.
	}
}


\newglossaryentry{seu}
{
	name = {SEU},
	long = {Single Event Upset},
	first = {\glsentrylong{seu} (\glsentryname{seu})},
	description = {
		A bit flip in memory caused by ionizing radiation penetrating the semiconductor 
		and releasing charge inside a transitor diffusion terminal. It is non-destructive
		for the semiconductor itself but if the FPGA configuration memory is affected,
		its operation will be altered.
	},
}

\newglossaryentry{hls}
{
	name = {HLS},
	long = {High Level Synthesis},
	description = {\emph{\glsentrylong{hls}}:
		A Xilinx tool that can compile an algorithm expressed in C/C++ to 
		a hardware description language (Verilog) ready for synthesis by
		the standard toolchain.
	},
}


\newglossaryentry{cma}
{
	name = {CMA},
	long = {Contiguous Memory Allocator},
	first = {\glsentrylong{cma} (\glsentryname{cma})},
	description = {	\emph{\glsentrylong{cma}}:
		A Linux kernel facility that allows the allocation of indefinitely large physically
		contiguous memory.
	},
}

\newglossaryentry{pinning}
{
	name = {memory pinning},
	description = {
		Marking a memory region as not moveable. That is, the pages may not be migrated or swapped out.
		Access to this memory region is guaranteed not to produce any page fault.
	},
	see = {migration,locking},
}

\newglossaryentry{locking}
{
	name = {memory locking},
	description = {
		Marking a memory region as not swappable. The locked pages can still be migrated, therefore
		a soft page fault may still occur.
	},
	see = {migration,pinning},
}

\newglossaryentry{migration}
{
	name = {migration},
	description = {
		The move of an allocated page to a different \gls{pfn} while updating reference to maintain
		consistency. This is useful in NUMA systems, where if a process is moved to another node,
		its allocated pages may also be transparently moved at a memory bank
		which has closer physical proximity to the new node.
	},
}

\newglossaryentry{pfn}
{
	name = {PFN},
	long = {Page Frame Number},
	description = {\emph{\glsentrylong{pfn}}:
		An index to the physical memory where a page is physically stored.
	},
}

\newglossaryentry{buddy}
{
	name = {buddy allocator},
	description = {
		The standard Linux kernel memory allocator. It is called so after the allocation algorithm
		it implements.
	},
}

\newglossaryentry{scatterlist}
{
	name = {scatterlist},
	description = {
		A software construct in the Linux kernel that abstracts the DMA scatter-gather functionality.
		Depending the architecture it may optimize transfers by coalescing or by processing the list
		in hardware if the DMA controller can support it.
	}
}

