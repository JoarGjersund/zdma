From bc2c57bc059a908c69c29987fc47999edeff9b7b Mon Sep 17 00:00:00 2001
From: Ioannis Galanommatis <galanom@gmail.com>
Date: Fri, 24 Nov 2017 01:06:24 +0200
Subject: [PATCH] allow fpga programming from kernel space

---
 drivers/char/xilinx_devcfg.c       | 158 ++++++++++++++++++++++++-------------
 include/linux/soc/xilinx/xdevcfg.h |  12 +++
 2 files changed, 113 insertions(+), 57 deletions(-)
 create mode 100644 include/linux/soc/xilinx/xdevcfg.h

diff --git a/drivers/char/xilinx_devcfg.c b/drivers/char/xilinx_devcfg.c
index bc6c13b9e187..f7a61010bb78 100644
--- a/drivers/char/xilinx_devcfg.c
+++ b/drivers/char/xilinx_devcfg.c
@@ -121,7 +121,7 @@ static const char * const fclk_name[] = {
  * @base_address: The virtual device base address of the device registers
  * @is_partial_bitstream: Status bit to indicate partial/full bitstream
  */
-struct xdevcfg_drvdata {
+static struct xdevcfg_drvdata {
 	struct device *dev;
 	struct cdev cdev;
 	dev_t devt;
@@ -142,7 +142,7 @@ struct xdevcfg_drvdata {
 	bool endian_swap;
 	char residue_buf[3];
 	int residue_len;
-};
+} *drvdata_ptr;
 
 /**
  * struct fclk_data - FPGA clock data
@@ -230,6 +230,67 @@ static irqreturn_t xdevcfg_irq(int irq, void *data)
 }
 
 /**
+ * xdevcfg_do_dma() - Do the DMA transfer of the bitstream to the PCAP
+ * @dma_addr:	DMA handle to the bitstream
+ * @count:	DMA transfer size in bytes
+ * returns:	0 for success
+ */
+static int xdevcfg_do_dma(dma_addr_t dma_addr, size_t count)
+{
+	u32 intr_reg;
+	unsigned long timeout;
+	int status = 0;
+	struct xdevcfg_drvdata *drvdata = drvdata_ptr;
+	
+	/* Enable DMA and error interrupts */
+	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_STS_OFFSET,
+				XDCFG_IXR_ALL_MASK);
+
+
+	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_MASK_OFFSET,
+				(u32) (~(XDCFG_IXR_D_P_DONE_MASK |
+				XDCFG_IXR_ERROR_FLAGS_MASK)));
+
+	drvdata->dma_done = 0;
+	drvdata->error_status = 0;
+
+	/* Initiate DMA write command */
+	if (count < 0x1000)
+		xdevcfg_writereg(drvdata->base_address +
+			XDCFG_DMA_SRC_ADDR_OFFSET, (u32)(dma_addr + 1));
+	else
+		xdevcfg_writereg(drvdata->base_address +
+			XDCFG_DMA_SRC_ADDR_OFFSET, (u32) dma_addr);
+
+	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_ADDR_OFFSET,
+				(u32)XDCFG_DMA_INVALID_ADDRESS);
+	
+	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_SRC_LEN_OFFSET,
+				(count - 1)/4 + 1); // convert bytes to words
+	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_LEN_OFFSET, 0);
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+
+	while (!drvdata->dma_done) {
+		if (time_after(jiffies, timeout)) {
+				status = -ETIMEDOUT;
+		}
+	}
+
+	if (!status && drvdata->error_status)
+		status = drvdata->error_status;
+
+	/* Disable the DMA and error interrupts */
+	intr_reg = xdevcfg_readreg(drvdata->base_address +
+					XDCFG_INT_MASK_OFFSET);
+	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_MASK_OFFSET,
+				intr_reg | (XDCFG_IXR_D_P_DONE_MASK |
+				XDCFG_IXR_ERROR_FLAGS_MASK));
+
+	return status;
+}
+
+/**
  * xdevcfg_write() - The is the driver write function.
  *
  * @file:	Pointer to the file structure.
@@ -242,12 +303,12 @@ static ssize_t
 xdevcfg_write(struct file *file, const char __user *buf, size_t count,
 		loff_t *ppos)
 {
+	static u64 csum = 0, csum_low = 0;
+	static u32 total = 0;
 	char *kbuf;
 	int status;
-	unsigned long timeout;
-	u32 intr_reg, dma_len;
+	u32 dma_len;
 	dma_addr_t dma_addr;
-	u32 transfer_length = 0;
 	struct xdevcfg_drvdata *drvdata = file->private_data;
 	size_t user_count = count;
 	int i;
@@ -285,12 +346,12 @@ xdevcfg_write(struct file *file, const char __user *buf, size_t count,
 		/* Look for sync word */
 		for (i = 0; i < count - 4; i++) {
 			if (memcmp(kbuf + i, "\x66\x55\x99\xAA", 4) == 0) {
-				pr_debug("Found normal sync word\n");
+				pr_info("Found normal sync word\n");
 				drvdata->endian_swap = 0;
 				break;
 			}
 			if (memcmp(kbuf + i, "\xAA\x99\x55\x66", 4) == 0) {
-				pr_debug("Found swapped sync word\n");
+				pr_info("Found swapped sync word\n");
 				drvdata->endian_swap = 1;
 				break;
 			}
@@ -315,55 +376,7 @@ xdevcfg_write(struct file *file, const char __user *buf, size_t count,
 		}
 	}
 
-	/* Enable DMA and error interrupts */
-	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_STS_OFFSET,
-				XDCFG_IXR_ALL_MASK);
-
-
-	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_MASK_OFFSET,
-				(u32) (~(XDCFG_IXR_D_P_DONE_MASK |
-				XDCFG_IXR_ERROR_FLAGS_MASK)));
-
-	drvdata->dma_done = 0;
-	drvdata->error_status = 0;
-
-	/* Initiate DMA write command */
-	if (count < 0x1000)
-		xdevcfg_writereg(drvdata->base_address +
-			XDCFG_DMA_SRC_ADDR_OFFSET, (u32)(dma_addr + 1));
-	else
-		xdevcfg_writereg(drvdata->base_address +
-			XDCFG_DMA_SRC_ADDR_OFFSET, (u32) dma_addr);
-
-	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_ADDR_OFFSET,
-				(u32)XDCFG_DMA_INVALID_ADDRESS);
-	/* Convert number of bytes to number of words.  */
-	if (count % 4)
-		transfer_length	= (count / 4 + 1);
-	else
-		transfer_length	= count / 4;
-	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_SRC_LEN_OFFSET,
-				transfer_length);
-	xdevcfg_writereg(drvdata->base_address + XDCFG_DMA_DEST_LEN_OFFSET, 0);
-
-	timeout = jiffies + msecs_to_jiffies(1000);
-
-	while (!drvdata->dma_done) {
-		if (time_after(jiffies, timeout)) {
-				status = -ETIMEDOUT;
-				goto error;
-		}
-	}
-
-	if (drvdata->error_status)
-		status = drvdata->error_status;
-
-	/* Disable the DMA and error interrupts */
-	intr_reg = xdevcfg_readreg(drvdata->base_address +
-					XDCFG_INT_MASK_OFFSET);
-	xdevcfg_writereg(drvdata->base_address + XDCFG_INT_MASK_OFFSET,
-				intr_reg | (XDCFG_IXR_D_P_DONE_MASK |
-				XDCFG_IXR_ERROR_FLAGS_MASK));
+	status = xdevcfg_do_dma(dma_addr, count);
 
 	/* If we didn't write correctly, then bail out. */
 	if (status) {
@@ -383,7 +396,6 @@ xdevcfg_write(struct file *file, const char __user *buf, size_t count,
 	return status;
 }
 
-
 /**
  * xdevcfg_read() - The is the driver read function.
  * @file:	Pointer to the file structure.
@@ -581,6 +593,35 @@ static int xdevcfg_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
+/**
+ * xdevcfg_program() - FPGA programming from kernel space
+ * @bitstream:	DMA handle to bitstream data
+ * @size:	Bitstream size
+ * @is_partial:	If the bitstream is partial or not
+ * returns:	The status that the DMA will return (zero for success)
+ *
+ */
+int xdevcfg_program(dma_addr_t bitstream, size_t size, bool is_partial)
+{
+	struct inode inode;
+	struct file file;
+	int status;
+	inode.i_cdev = &drvdata_ptr->cdev;
+	file.private_data = drvdata_ptr;
+	drvdata_ptr->is_partial_bitstream = is_partial;
+
+	xdevcfg_open(&inode, &file);
+
+	status = xdevcfg_do_dma(bitstream, size);
+
+	drvdata_ptr->residue_len = 0;
+	xdevcfg_release(&inode, &file);
+	return status;
+
+}
+EXPORT_SYMBOL_GPL(xdevcfg_program);
+
+
 static const struct file_operations xdevcfg_fops = {
 	.owner = THIS_MODULE,
 	.write = xdevcfg_write,
@@ -589,6 +630,7 @@ static const struct file_operations xdevcfg_fops = {
 	.release = xdevcfg_release,
 };
 
+
 /*
  * The following functions are the routines provided to the user to
  * set/get the status bit value in the control/lock registers.
@@ -2036,6 +2078,8 @@ static int xdevcfg_drv_probe(struct platform_device *pdev)
 
 	clk_disable(drvdata->clk);
 
+	drvdata_ptr = drvdata;
+
 	return 0;		/* Success */
 
 failed8:
diff --git a/include/linux/soc/xilinx/xdevcfg.h b/include/linux/soc/xilinx/xdevcfg.h
new file mode 100644
index 000000000000..31a275612046
--- /dev/null
+++ b/include/linux/soc/xilinx/xdevcfg.h
@@ -0,0 +1,12 @@
+#pragma once
+
+/**
+ * xdevcfg_program() - FPGA programming from kernel space
+ * @bitstream:  DMA handle to bitstream data
+ * @size:       Bitstream size
+ * @is_partial: If the bitstream is partial or not
+ * returns:     The status that the DMA will return (zero for success)
+ *
+ */
+int xdevcfg_program(dma_addr_t bitstream, size_t size, bool is_partial);
+
-- 
2.13.0

